module type LANG = sig
  include Names.CONT_NAMES

  type computation

  val string_of_computation : computation -> string

  module M : Util.Monad.BRANCH
  module Memory : Language.MEMORY with module M = M

  (* compute_nf computes the normal form of an operational configuration,
     or None when we detect that the operational configuration diverges.*)

  type normal_form

  val string_of_nf : normal_form -> string


  type opconf = computation * Memory.memory
  val compute_nf : opconf -> (normal_form option * Memory.memory) option

  (* Abstracted values correspond to the observable part of a value.
      They are also called ultimate patterns.
  *)
  type abstract_val

  val string_of_abstract_val : abstract_val -> string
  val names_of_abstract_val : abstract_val -> name list

  (*Interactive name contexts are typing contexts mapping names to interactive types.*)
  type name_type_ctx 

  val empty_name_type_ctx : name_type_ctx
  val concat_name_type_ctx : name_type_ctx -> name_type_ctx -> name_type_ctx
  val string_of_name_type_ctx : name_type_ctx -> string
  val get_names_from_name_type_ctx : name_type_ctx -> name list


  (* Interactive environments γ are partial maps from names to interactive values*)
  type interactive_env

  val empty_ienv : interactive_env
  val concat_ienv : interactive_env -> interactive_env -> interactive_env
  val string_of_interactive_env : interactive_env -> string

  (* The typed focusing process implemented by abstract_kind
      decomposes a normal form into:
       - an abstract value for the observable part,
       - a typed interactive environment for the negative part. *)

  (* Temporary *)
  type abstract_normal_form
  val abstract_kind :
    normal_form ->
    name_type_ctx ->
    (abstract_normal_form * interactive_env * name_type_ctx) option

  val get_subject_names : abstract_normal_form -> name option
  val get_support : abstract_normal_form -> name list

  (* The first argument is a string inserted between the kind and the abstract values *)
  val string_of_a_nf : string -> abstract_normal_form -> string

  val is_equiv_a_nf :
    name Util.Namespan.namespan -> abstract_normal_form -> abstract_normal_form -> (name Util.Namespan.namespan) option


  (* From the interactive name context Γ_P,
     we generate all the possible pairs (A,Δ) such that
     Γ_P;_ ⊢ A ▷ Δ
     Freshness of names that appear in Δ is guaranteed by a gensym, so that we do not need to provide Γ_O. *)
  val generate_a_nf :
    name_type_ctx -> (abstract_normal_form * name_type_ctx) M.m

  (* The typing judgment of an abstracted value Γ_P;Γ_O ⊢ A : τ ▷ Δ
     produces the interactive name contexts Δ of fresh names introduced by A.
     it returns None when the type checking fails.
     The context Γ_P is used to retrieve the existing polymorphic names, and to check for freshness other names.
     The contexts Γ_O is used to check for freshness of names *)  

  val type_check_a_nf :
    name_type_ctx ->
    name_type_ctx ->
    abstract_normal_form ->
    name_type_ctx option

  val concretize_a_nf : interactive_env -> abstract_normal_form -> (computation*interactive_env) option

  val unify_abstract_val :
    name Util.Namespan.namespan ->
    abstract_val ->
    abstract_val ->
    name Util.Namespan.namespan option

  val get_typed_computation :
    string -> in_channel -> computation * name_type_ctx

  (* The function get_typed_ienv
     retrive a module declaration and its signature from the two in_channel taken as input.
     It evaluates the list of computation declarations
     into a list of value declarations together with the memory
     generated by this evaluation. *)
  val get_typed_ienv :
    in_channel ->
    in_channel ->
    interactive_env * Memory.memory * name_type_ctx * name_type_ctx
end
