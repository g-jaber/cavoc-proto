module type LANG = sig
  module Names : Names.NAMES
  module EvalMonad : Util.Monad.RUNNABLE
  module BranchMonad : Util.Monad.BRANCH

  type opconf

  val string_of_opconf : opconf -> string
  val pp_opconf : Format.formatter -> opconf -> unit

  type store

  val string_of_store : store -> string
  val pp_store : Format.formatter -> store -> unit

  module Storectx : Typectx.TYPECTX

  val infer_type_store : store -> Storectx.t

  module Namectx : Typectx.TYPECTX with type name = Names.name

  (*Interactive name contexts are typing contexts mapping names to interactive types.*)

  (* Interactive environments γ are partial maps from names to interactive values*)
  type interactive_env [@@deriving to_yojson]

  val empty_ienv : interactive_env
  val concat_ienv : interactive_env -> interactive_env -> interactive_env
  val pp_ienv : Format.formatter -> interactive_env -> unit
  val string_of_ienv : interactive_env -> string

  (* The typed focusing process implemented by abstracting_nf
      decomposes a normal form into:
       - an abstract normal form for the observable part;
       - a typed interactive environment for the negative part. *)

  (* abstract normal forms can be thought of named copatterns when the language is
     of signature Language.WITHAVAL_INOUT. *)

  type abstract_normal_form

  val eval :
    opconf * Namectx.t * Storectx.t ->
    ((abstract_normal_form * Namectx.t * Storectx.t) * interactive_env * store)
    EvalMonad.m

  (* abstracting_nf nf Γₒ Σ returns a triple (anf,γ,Δ,Σ')
      where anf{γ} = nf and Σ;Γₒ ⊢ anf ▷ Δ,Σ' and Σ;Γₒ ⊢ γ:Δ.
      We should check whether we take into account disclosure of locations currently.*)

  val get_subject_name : abstract_normal_form -> Names.name option
  val get_support : abstract_normal_form -> Names.name list

  (* The first argument is a string inserted between
     the negative part of the normal form
     and the abstract values filling the positive parts *)
  val pp_a_nf :
    pp_dir:(Format.formatter -> unit) ->
    Format.formatter ->
    abstract_normal_form ->
    unit

  val string_of_a_nf : string -> abstract_normal_form -> string

  val is_equiv_a_nf :
    Names.name Util.Namespan.namespan ->
    abstract_normal_form ->
    abstract_normal_form ->
    Names.name Util.Namespan.namespan option

  (* From the interactive name context Γ_P,
     we generate all the possible pairs (A,Δ,Γ'_P) formed by an abstracted normal form A such that
     Γ_P;_ ⊢ A ▷ Δ
     Freshness of names that appear in Δ is guaranteed by a gensym, so that we do not need to provide Γ_O. *)
  val generate_a_nf :
    Storectx.t ->
    Namectx.t ->
    (abstract_normal_form * Namectx.t * Namectx.t) BranchMonad.m

  (* The typing judgment of an abstracted normal form Γ_P;Γ_O ⊢ A ▷ Δ
     produces the interactive name context (Δ,Γ'_P) of fresh names introduced by A.
     It returns None when the type checking fails.
     The context Γ_P is used to retrieve the existing polymorphic names, and to check for freshness of other names.
     The contexts Γ_O is used to check for freshness of names *)

  val type_check_a_nf :
    Namectx.t ->
    Namectx.t ->
    abstract_normal_form ->
    (Namectx.t * Namectx.t) option

  val concretize_a_nf :
    store -> interactive_env -> abstract_normal_form -> opconf * interactive_env
end

module type LANG_WITH_INIT = sig
  include LANG

  val get_typed_opconf : string -> Lexing.lexbuf -> opconf * Namectx.t

  (* The function get_typed_ienv
     retrive a module declaration and its signature from the two in_channel taken as input.
     It evaluates the list of computation declarations
     into a list of value declarations together with the store
     generated by this evaluation.
     We return a Proponent and an Opponent name context. *)
  val get_typed_ienv :
    Lexing.lexbuf ->
    Lexing.lexbuf ->
    interactive_env * store * Namectx.t * Namectx.t
end

(* The following functor create a module of type Interactive.LANG_WITH_INIT
   from a module OpLang of type Language.WITHAVAL_NEG *)
module Make (OpLang : Language.WITHAVAL_NEG) : LANG_WITH_INIT = struct
  module EvalMonad = OpLang.EvalMonad
  module Names = OpLang.Names
  module BranchMonad = OpLang.AVal.BranchMonad
  module Store = OpLang.Store

  type opconf = OpLang.opconf

  let pp_opconf = OpLang.pp_opconf
  let string_of_opconf = Format.asprintf "%a" pp_opconf

  type store = OpLang.Store.store

  let string_of_store = OpLang.Store.string_of_store
  let pp_store = OpLang.Store.pp_store

  module Storectx = OpLang.Store.Storectx

  let infer_type_store = OpLang.Store.infer_type_store

  module Namectx = OpLang.Namectx

  (* Interactive environments γ are partial maps from names to interactive values*)
  type interactive_env = OpLang.interactive_env [@@deriving to_yojson]

  let pp_ienv = OpLang.pp_ienv
  let string_of_ienv = Format.asprintf "%a" pp_ienv
  let empty_ienv = OpLang.empty_ienv
  let concat_ienv = OpLang.concat_ienv

  let concretize_a_nf store ienv (a_nf_term, store') =
    let f_val = OpLang.AVal.subst_names ienv in
    let f_fn nn = Util.Pmap.lookup_exn nn ienv in
    let f_cn = f_fn in
    let f_ectx () = () in
    let nf_term' = OpLang.Nf.map ~f_val ~f_fn ~f_cn ~f_ectx a_nf_term in
    Util.Debug.print_debug "Updating the store";
    let newstore = Store.update_store store store' in
    ((OpLang.refold_nf_term nf_term', newstore), ienv)

  type abstract_normal_form =
    (OpLang.AVal.abstract_val, unit, Names.name, Names.name) OpLang.Nf.nf_term
    * Store.store

  let labels_of_a_nf_term =
    OpLang.Nf.apply_val [] OpLang.AVal.labels_of_abstract_val

  let abstracting_store = OpLang.Store.restrict
  (* TODO Deal with the abstraction process of the heap properly *)

  let abstracting_nf_term nf_term namectxO =
    (* This is bugged, we should first *)
    let get_ty nn =
      let nty = Namectx.lookup_exn namectxO nn in
      OpLang.negating_type nty in
    let nf_typed_term = OpLang.type_annotating_val get_ty nf_term in
    let f_val (value, nty) =
      let (aval, ienv, lnamectx) = OpLang.AVal.abstracting_value value nty in
      (aval, (ienv, lnamectx)) in
    let empty_res = (Util.Pmap.empty, Util.Pmap.empty) in
    OpLang.Nf.map_val empty_res f_val nf_typed_term
  (*
    let f_call (nn, value, ()) = 
      let ty = Util.Pmap.lookup_exn nn namectxO in
      let nty = OpLang.negating_type ty in
      let (aval, ienv, lnamectx) = OpLang.AVal.abstracting_value value nty in
      ((nn, aval, ()), (ienv, lnamectx)) in
    let f_ret (nn, value) =
      let ty = Util.Pmap.lookup_exn nn namectxO in
      let nty = OpLang.negating_type ty in
      let (aval, ienv, lnamectx) = OpLang.AVal.abstracting_value value nty in
      ((nn, aval), (ienv, lnamectx)) in
    let f_exn (nn, value) =
      let (aval, ienv, lnamectx) =
        OpLang.AVal.abstracting_value value OpLang.exception_type in
      ((nn, aval), (ienv, lnamectx)) in
    let f_error nn = (nn, (empty_ienv, empty_name_ctx)) in
    OpLang.Nf.map_cons ~f_call ~f_ret ~f_exn ~f_error nf_term*)

  let abstracting_nf (nf_term, store) namectxO storectx_discl =
    let (a_nf_term, (ienv, lnamectx)) = abstracting_nf_term nf_term namectxO in
    if OpLang.Nf.is_error a_nf_term then None
    else
      let label_l = labels_of_a_nf_term a_nf_term in
      let storectx = OpLang.Store.infer_type_store store in
      Util.Debug.print_debug @@ "The full store context is "
      ^ OpLang.Store.Storectx.to_string storectx;
      let storectx_discl' = OpLang.Store.restrict_ctx storectx label_l in
      let storectx_discl'' =
        OpLang.Store.Storectx.concat storectx_discl storectx_discl' in
      Util.Debug.print_debug @@ "The new diclosed store context is "
      ^ OpLang.Store.Storectx.to_string storectx_discl'';
      let store_discl = abstracting_store storectx_discl' store in
      Some ((a_nf_term, store_discl), ienv, lnamectx, storectx_discl'')

  (* Notice that the disclosure process is in fact more complex
     since the image of  store_discl might itself has
     labels that becomes diclosed.
     This computation would necessitate an iterative process. *)

  let get_subject_name (a_nf_term, _) =
    let f_fn nn = (nn, Some nn) in
    let f_cn nn = (nn, Some nn) in
    match snd @@ OpLang.Nf.map_fn None f_fn a_nf_term with
    | None -> snd @@ OpLang.Nf.map_cn None f_cn a_nf_term
    | Some _ as res -> res

  let get_support (a_nf_term, _) =
    OpLang.Nf.apply_val [] OpLang.AVal.names_of_abstract_val a_nf_term
  (*TODO: take into account the store part*)

  let pp_a_nf ~pp_dir fmt (a_nf_term, store) =
    let pp_ectx fmt () = Format.pp_print_string fmt "" in
    let pp_a_nf_term =
      OpLang.Nf.pp_nf_term ~pp_dir OpLang.AVal.pp_abstract_val pp_ectx
        OpLang.Names.pp_name OpLang.Names.pp_name in
    if store = Store.empty_store then pp_a_nf_term fmt a_nf_term
    else Format.fprintf fmt "%a,%a" pp_a_nf_term a_nf_term Store.pp_store store

  let string_of_a_nf dir =
    let pp_dir fmt = Format.pp_print_string fmt dir in
    Format.asprintf "%a" (pp_a_nf ~pp_dir)

  let eval (opconf, namectxO, storectx_discl) =
    let open EvalMonad in
    let* (term', store') = OpLang.normalize_opconf opconf in
    let nf_term = OpLang.get_nf_term term' in
    match abstracting_nf (nf_term, store') namectxO storectx_discl with
    | Some ((a_nf_term, discl_store), ienv, lnamectx, storectx_discl) ->
        return
          (((a_nf_term, discl_store), lnamectx, storectx_discl), ienv, store')
    | None -> fail ()

  include OpLang.AVal.BranchMonad

  let fill_abstract_val storectx namectxP nf_skeleton =
    let gen_val ty = OpLang.AVal.generate_abstract_val storectx namectxP ty in
    OpLang.Nf.abstract_nf_term_m ~gen_val nf_skeleton

  let generate_a_nf storectx namectxP =
    let namectxP' =
      Util.Pmap.filter_dom
        (fun n -> Names.is_fname n || Names.is_cname n)
        namectxP in
    let namectxP'' = Util.Pmap.map_im OpLang.negating_type namectxP' in
    let* _ = return @@ Util.Debug.print_debug @@ "Generating the skeleton " in
    let* skel = OpLang.generate_nf_term namectxP'' in
    let* _ = return @@ Util.Debug.print_debug @@ "Filling the skeleton " in
    let* (a_nf_term, lnamectx) = fill_abstract_val storectx namectxP skel in
    let* store = Store.generate_store storectx in
    return ((a_nf_term, store), lnamectx, namectxP)

  let type_check_a_nf namectxP namectxO (nf_term, _) =
    let name_ctx = namectxO in
    let type_check_val aval nty =
      let ty = OpLang.negating_type nty in
      OpLang.AVal.type_check_abstract_val namectxP namectxO ty aval in
    let empty_res = Util.Pmap.empty in
    match
      OpLang.type_check_nf_term ~empty_res ~name_ctx ~type_check_val nf_term
    with
    | None -> None
    | Some lnamectx -> Some (lnamectx, namectxP)

  (*TODO: Type check the store part and
     check that the disclosure process is respected*)

  (*
     let type_check_a_nf namectxP namectxO (a_nf, _) =
       let aux nn aval =
         let nty = Util.Pmap.lookup_exn nn namectxO in
         let ty = OpLang.negating_type nty in
         OpLang.AVal.type_check_abstract_val namectxP namectxO ty aval in
       let f_call (fn, aval, ()) = aux fn aval in
       let f_ret (cn, aval) = aux cn aval in
       let f_exn (_, aval) =
         OpLang.AVal.type_check_abstract_val namectxP namectxO
           OpLang.exception_type aval in
       let f_error _ = Some Util.Pmap.empty in
       match OpLang.Nf.apply_cons ~f_call ~f_ret ~f_exn ~f_error a_nf with
       | None -> None
       | Some lnamectx -> Some (lnamectx, namectxP)
  *)

  (* Beware that is_equiv_a_nf does not check the equivalence of
     the store part of abstract normal forms.
     This is needed for the POGS equivalence. *)
  let is_equiv_a_nf span (anf1, _) (anf2, _) =
    OpLang.Nf.equiv_nf_term OpLang.AVal.unify_abstract_val span anf1 anf2

  let get_typed_ienv = OpLang.get_typed_ienv

  let get_typed_opconf nbprog lexBuffer =
    let (opconf, _, namectxO) = OpLang.get_typed_opconf nbprog lexBuffer in
    (opconf, namectxO)
end
