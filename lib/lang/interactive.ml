module type LANG = sig
  module EvalMonad : Util.Monad.RUNNABLE
  module BranchMonad : Util.Monad.BRANCH

  (* Interactive environments γ are partial maps from names to interactive values*)
  module IEnv : Ienv.IENV

  type opconf

  val string_of_opconf : opconf -> string
  val pp_opconf : Format.formatter -> opconf -> unit

  type store

  val string_of_store : store -> string
  val pp_store : Format.formatter -> store -> unit

  module Storectx : Typectx.TYPECTX

  val infer_type_store : store -> Storectx.t

  (* The typed focusing process implemented by abstracting_nf
      decomposes a normal form into:
       - an abstract normal form for the observable part;
       - a typed interactive environment for the negative part. *)

  (* abstract normal forms can be thought of named copatterns when the language is
     of signature Language.WITHAVAL_INOUT. *)

  type abstract_normal_form

  val eval :
    opconf * IEnv.Renaming.Namectx.t * Storectx.t ->
    ((abstract_normal_form * IEnv.Renaming.Namectx.t * Storectx.t)
    * IEnv.t
    * store)
    EvalMonad.m

  (* abstracting_nf nf Γₒ Σ returns a triple (anf,γ,Σ')
      where anf{γ} = nf and Σ;Γₒ ⊢ anf ▷ Δ,Σ' and Σ;Γₒ ⊢ γ:Δ.
      We should check whether we take into account disclosure of locations currently.*)

  val get_subject_name :
    abstract_normal_form -> IEnv.Renaming.Namectx.Names.name option

  (* The first argument is a string inserted between
     the negative part of the normal form
     and the abstract values filling the positive parts *)
  val pp_a_nf :
    pp_dir:(Format.formatter -> unit) ->
    Format.formatter ->
    abstract_normal_form ->
    unit

  val string_of_a_nf : string -> abstract_normal_form -> string

  val is_equiv_a_nf :
    IEnv.Renaming.Namectx.Names.name Util.Namespan.namespan ->
    abstract_normal_form ->
    abstract_normal_form ->
    IEnv.Renaming.Namectx.Names.name Util.Namespan.namespan option

  (* From the interactive name context Γ_P,
     we generate all the possible pairs (A,Δ,Γ'_P) formed by an abstracted normal form A such that
     Γ_P;_ ⊢ A ▷ Δ
     Freshness of names that appear in Δ is guaranteed by a gensym, so that we do not need to provide Γ_O. *)
  val generate_a_nf :
    Storectx.t ->
    IEnv.Renaming.Namectx.t ->
    (abstract_normal_form * IEnv.Renaming.Namectx.t * IEnv.Renaming.Namectx.t)
    BranchMonad.m

  (* The typing judgment of an abstracted normal form Γ_P;Γ_O ⊢ A ▷ Δ
      takes as arguments (Γ_P,Γ_O,A,Δ)
    and produces the interactive name context Γ'_P where the consumed linear resources of Γ_P has been removed.
     It returns None when the type checking fails. *)

  val type_check_a_nf :
    IEnv.Renaming.Namectx.t ->
    IEnv.Renaming.Namectx.t ->
    abstract_normal_form * IEnv.Renaming.Namectx.t ->
    IEnv.Renaming.Namectx.t option

  val concretize_a_nf :
    store ->
    IEnv.t ->
    abstract_normal_form * IEnv.Renaming.Namectx.t ->
    opconf * IEnv.t
end

module type LANG_WITH_INIT = sig
  include LANG

  val get_typed_opconf :
    string -> Lexing.lexbuf -> opconf * IEnv.Renaming.Namectx.t

  (* The function get_typed_ienv
     retrive a module declaration and its signature from the two in_channel taken as input.
     It evaluates the list of computation declarations
     into a list of value declarations together with the store
     generated by this evaluation.
     We return a Proponent and an Opponent name context. *)
  val get_typed_ienv :
    Lexing.lexbuf ->
    Lexing.lexbuf ->
    IEnv.t * store * IEnv.Renaming.Namectx.t * IEnv.Renaming.Namectx.t
end

(* The following functor create a module of type Interactive.LANG_WITH_INIT
   from a module OpLang of type Language.WITHAVAL_NEG *)
module Make (OpLang : Language.WITHAVAL_NEG) : LANG_WITH_INIT = struct
  module EvalMonad = OpLang.EvalMonad
  module BranchMonad = OpLang.AVal.BranchMonad
  module IEnv = OpLang.IEnv
  module Store = OpLang.Store

  type opconf = OpLang.opconf

  let pp_opconf = OpLang.pp_opconf
  let string_of_opconf = Format.asprintf "%a" pp_opconf

  type store = OpLang.Store.store

  let string_of_store = OpLang.Store.string_of_store
  let pp_store = OpLang.Store.pp_store

  module Storectx = OpLang.Store.Storectx

  let infer_type_store = OpLang.Store.infer_type_store

  type abstract_normal_form =
    ( OpLang.AVal.abstract_val,
      unit,
      IEnv.Renaming.Namectx.Names.name,
      IEnv.Renaming.Namectx.Names.name )
    OpLang.Nf.nf_term
    * Store.store

  let pp_a_nf ~pp_dir fmt (a_nf_term, store) =
    let pp_ectx fmt () = Format.pp_print_string fmt "" in
    let pp_a_nf_term =
      OpLang.Nf.pp_nf_term ~pp_dir OpLang.AVal.pp_abstract_val pp_ectx
        OpLang.IEnv.Renaming.Namectx.Names.pp_name
        OpLang.IEnv.Renaming.Namectx.Names.pp_name in
    if store = Store.empty_store then pp_a_nf_term fmt a_nf_term
    else Format.fprintf fmt "%a,%a" pp_a_nf_term a_nf_term Store.pp_store store

  let string_of_a_nf dir =
    let pp_dir fmt = Format.pp_print_string fmt dir in
    Format.asprintf "%a" (pp_a_nf ~pp_dir)

  let concretize_a_nf store ienv ((a_nf_term, store'), lnamectx) =
    Util.Debug.print_debug @@ "concretize the a nf "
    ^ string_of_a_nf "" (a_nf_term, store');
    (* Taking ienv:Γ→Θ, then we lift it into ienv':Γ → Θ+Δ with Δ=lnamectx *)
    let ienv' = IEnv.weaken_r ienv lnamectx in
    (* Old version: we use to tensor it
    let id_lnamectx = IEnv.embed_renaming @@ IEnv.Renaming.id lnamectx in
    let ienv' = IEnv.tensor ienv id_lnamectx in*)
    (* we weaken the abstract term from *)
    Util.Debug.print_debug @@ "Before creating the renaming";
    let renaming = OpLang.Renaming.weak_r lnamectx (IEnv.im ienv) in
    Util.Debug.print_debug @@ "Before lifting the renaming "
    ^ IEnv.Renaming.to_string renaming;
    let renaming = IEnv.embed_renaming @@ renaming in
    Util.Debug.print_debug @@ "Renaming  : " ^ IEnv.to_string renaming;
    (*    let a_nf_term' =
      OpLang.Nf.map
        ~f_val:(fun aval -> OpLang.AVal.rename aval renaming)
        ~f_fn:Fun.id ~f_cn:Fun.id ~f_ectx:Fun.id a_nf_term in
    Util.Debug.print_debug @@ "The weaken_r abstract normal form term is :"
    ^ OpLang.Nf.string_of_nf_term "" OpLang.AVal.string_of_abstract_val
        (fun () -> "")
        IEnv.Renaming.Namectx.Names.string_of_name
        IEnv.Renaming.Namectx.Names.string_of_name a_nf_term;*)
    (* Then we substitute the names *)
    let ienv'' = IEnv.copairing ienv' renaming in
    let f_val = OpLang.AVal.subst_pnames ienv'' in
    let f_fn nn = IEnv.lookup_exn ienv'' nn in
    let f_cn = f_fn in
    let f_ectx () = () in
    let nf_term' = OpLang.Nf.map ~f_val ~f_fn ~f_cn ~f_ectx a_nf_term in
    (* Then we deal with the store *)
    (* TODO: We should also weaken_r the abstract values present in the image of store'*)
    Util.Debug.print_debug "Updating the store";
    let newstore = Store.update_store store store' in
    let newterm = OpLang.refold_nf_term nf_term' in
    Util.Debug.print_debug @@ "Once concretized we get "
    ^ OpLang.string_of_term newterm;
    ((newterm, newstore), ienv')

  let labels_of_a_nf_term =
    OpLang.Nf.apply_val [] OpLang.AVal.labels_of_abstract_val

  let abstracting_store = OpLang.Store.restrict
  (* TODO Deal with the abstraction process of the heap properly *)

  let abstracting_nf_term nf_term namectxO =
    (* This is bugged, we should first *)
    Util.Debug.print_debug @@ "Trying to abstract the nf_term ";
    let get_ty nn =
      Util.Debug.print_debug @@ "Looking for "
      ^ IEnv.Renaming.Namectx.Names.string_of_name nn
      ^ " in "
      ^ IEnv.Renaming.Namectx.to_string namectxO;
      let nty = IEnv.Renaming.Namectx.lookup_exn namectxO nn in
      Util.Debug.print_debug @@ "The type of "
      ^ IEnv.Renaming.Namectx.Names.string_of_name nn
      ^ " is "
      ^ OpLang.string_of_negative_type nty;
      OpLang.negating_type nty in
    Util.Debug.print_debug "going to call type_annotating_val";
    let nf_typed_term = OpLang.type_annotating_val get_ty nf_term in
    let f_val (value, ty) =
      Util.Debug.print_debug @@ " Abstracting the value "
      ^ OpLang.string_of_value value
      ^ " of type " ^ OpLang.string_of_type ty;
      let (aval, ienv) = OpLang.AVal.abstracting_value value namectxO ty in
      (aval, ienv) in
    let empty_res = IEnv.empty namectxO in
    OpLang.Nf.map_val empty_res f_val nf_typed_term

  let abstracting_nf (nf_term, store) namectxO storectx_discl =
    let (a_nf_term, ienv) = abstracting_nf_term nf_term namectxO in
    if OpLang.Nf.is_error a_nf_term then None
    else
      let label_l = labels_of_a_nf_term a_nf_term in
      let storectx = OpLang.Store.infer_type_store store in
      Util.Debug.print_debug @@ "The full store context is "
      ^ OpLang.Store.Storectx.to_string storectx;
      let storectx_discl' = OpLang.Store.restrict_ctx storectx label_l in
      let storectx_discl'' =
        OpLang.Store.Storectx.concat storectx_discl storectx_discl' in
      Util.Debug.print_debug @@ "The new diclosed store context is "
      ^ OpLang.Store.Storectx.to_string storectx_discl'';
      let store_discl = abstracting_store storectx_discl' store in
      Some ((a_nf_term, store_discl), ienv, storectx_discl'')

  (* Notice that the disclosure process is in fact more complex
     since the image of  store_discl might itself has
     labels that becomes diclosed.
     This computation would necessitate an iterative process. *)

  let get_subject_name (a_nf_term, _) =
    let f_fn nn = (nn, Some nn) in
    let f_cn nn = (nn, Some nn) in
    match snd @@ OpLang.Nf.map_fn None f_fn a_nf_term with
    | None -> snd @@ OpLang.Nf.map_cn None f_cn a_nf_term
    | Some _ as res -> res

  let eval (opconf, namectxO, storectx_discl) =
    let open EvalMonad in
    let* (term', store') = OpLang.normalize_opconf opconf in
    let nf_term = OpLang.get_nf_term term' in
    match abstracting_nf (nf_term, store') namectxO storectx_discl with
    | Some ((a_nf_term, discl_store), ienv, storectx_discl) ->
        let lnamectx = IEnv.dom ienv in
        return
          (((a_nf_term, discl_store), lnamectx, storectx_discl), ienv, store')
    | None -> fail ()

  include OpLang.AVal.BranchMonad

  let fill_abstract_val storectx namectxP_pmap nf_skeleton =
    let gen_val ty =
      OpLang.AVal.generate_abstract_val storectx namectxP_pmap ty in
    OpLang.Nf.abstract_nf_term_m ~gen_val nf_skeleton

  let generate_a_nf storectx namectxP =
    let* _ = return @@ Util.Debug.print_debug @@ "Generating the skeleton " in
    let* skel = OpLang.generate_nf_term namectxP in
    let* _ = return @@ Util.Debug.print_debug @@ "Filling the skeleton " in
    let* (a_nf_term, lnamectx) = fill_abstract_val storectx namectxP skel in
    let* store = Store.generate_store storectx in
    return ((a_nf_term, store), lnamectx, namectxP)

  let type_check_a_nf namectxP namectxO ((nf_term, _), lnamectx) =
    (* Why do we ignore the store ? *)
    let name_ctx = namectxP in
    let type_check_val aval nty =
      let ty = OpLang.negating_type nty in
      OpLang.AVal.type_check_abstract_val namectxP namectxO ty (aval, lnamectx)
    in
    OpLang.type_check_nf_term ~name_ctx ~type_check_val nf_term

  (*TODO: Type check the store part and
     check that the disclosure process is respected*)

  (* Beware that is_equiv_a_nf does not check the equivalence of
     the store part of abstract normal forms.
     This is needed for the POGS equivalence. *)
  let is_equiv_a_nf span (anf1, _) (anf2, _) =
    OpLang.Nf.equiv_nf_term OpLang.AVal.unify_abstract_val span anf1 anf2

  let get_typed_ienv = OpLang.get_typed_ienv

  let get_typed_opconf nbprog lexBuffer =
    let (opconf, _, namectxO) = OpLang.get_typed_opconf nbprog lexBuffer in
    (opconf, namectxO)
end
