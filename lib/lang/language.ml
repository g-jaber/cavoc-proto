module type BASIC = sig
  module Name : Names.CONT_NAMES

  type term

  val string_of_term : term -> string

  type value

  val string_of_value : value -> string

  type negative_val

  val filter_negative_val : value -> negative_val option
  val string_of_negative_val : negative_val -> string

  type interactive_env = (Name.name, negative_val) Util.Pmap.pmap

  val empty_ienv : interactive_env
  val concat_ienv : interactive_env -> interactive_env -> interactive_env
  val string_of_interactive_env : interactive_env -> string

  type eval_context

  val string_of_eval_context : eval_context -> string
  val embed_eval_context : eval_context -> negative_val

  val get_kind_nf :
    term -> (value, eval_context, Name.name, Name.cont_name) Nf.kind_nf

  val refold_kind_nf :
    (value, unit, negative_val, negative_val) Nf.kind_nf -> term
end

module type TYPED = sig
  include BASIC

  (*module Name : Names.NAME*)
  type typ
  type typevar
  type typename

  val string_of_type : typ -> string
  val string_of_typename : typename -> string

  type negative_type

  val get_negative_type : typ -> negative_type option
  val string_of_negative_type : negative_type -> string

  type name_ctx = (Name.name, negative_type) Util.Pmap.pmap

  val empty_name_ctx : name_ctx

  val concat_name_ctx :
    name_ctx -> name_ctx -> name_ctx

  val string_of_name_ctx : name_ctx -> string
  val get_names_from_name_ctx : name_ctx -> Name.name list
  val exception_type : typ

  val generate_typename_subst :
    typevar list -> typename list * (typevar, typ) Util.Pmap.pmap

  val apply_type_subst : typ -> (typevar, typ) Util.Pmap.pmap -> typ
end

module type STORE = sig
  type store

  val string_of_store : store -> string
  val empty_store : store

  type store_ctx

  val empty_store_ctx : store_ctx
  val string_of_store_ctx : store_ctx -> string
  val concat_store_ctx : store_ctx -> store_ctx -> store_ctx
  val infer_type_store : store -> store_ctx

  (* update_store μ μ' is equal to μ[μ'] *)
  val update_store : store -> store -> store

  val restrict :  store_ctx -> store -> store

  module M : Util.Monad.BRANCH
  (* *)

  val generate_store : store_ctx -> store M.m
end

module type COMP = sig
  include BASIC
  include TYPED
  module Store : STORE

  type opconf = term * Store.store

  (* Evaluation of programs may produces:
     - divergence
     - uncatchable error
     - raised exception that has not (yet) been caught
     - values
     - callbacks to function provided by another module
  *)

  val normalize_opconf : opconf -> opconf option
  val get_typed_term : string -> in_channel -> term * typ * name_ctx

  (* We retrive a module declaration and its signature from the two in_channel taken as input.
     We evaluate the list of computation declarations into a list of value declarations together with the store
     generated by this evaluation.
     We return two typing contexts, respectively for the names in the domain of the interactive env,
     and the one contains in the values of its image. *)
  val get_typed_interactive_env :
    in_channel ->
    in_channel ->
    interactive_env * Store.store * name_ctx * name_ctx
end

module type WITHAVAL = sig
  include COMP

  module AVal :
    Abstract_val.AVAL
      with type name = Name.name
       and type value = value
       and type negative_val = negative_val
       and type typ = typ
       and type negative_type = negative_type
       and type typevar = typevar
       and module M = Store.M
end

module type WITHAVAL_INOUT = sig
  include COMP

  module AVal :
    Abstract_val.AVAL_INOUT
      with type name = Name.name
       and type value = value
       and type negative_val = negative_val
       and type typ = typ
       and type negative_type = negative_type
       and type typevar = typevar
       and module M = Store.M
end

module type WITHAVAL_NEG = sig
  include COMP

  module AVal :
    Abstract_val.AVAL_NEG
      with type name = Name.name
       and type value = value
       and type negative_val = negative_val
       and type typ = typ
       and type negative_type = negative_type
       and type typevar = typevar
       and module M = Store.M
end