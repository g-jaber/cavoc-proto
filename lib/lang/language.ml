module type BASIC = sig
  include Names.NAME

  type term

  val string_of_term : term -> string

  type value

  val string_of_value : value -> string

  type val_env = (name, value) Util.Pmap.pmap
  type eval_ctx

  val string_of_eval_ctx : eval_ctx -> string
  val fill_hole : eval_ctx -> value -> term
  val apply_value : value -> value -> term
end

module type TYPED = sig
  include BASIC

  type typ
  type typevar
  type typename

  val string_of_type : typ -> string
  val string_of_typename : typename -> string

  type name_ctx = (name, typ) Util.Pmap.pmap

  val get_input_type : typ -> typevar list * typ
  val get_output_type : typ -> typ
  val exception_type : typ

  val generate_typename_subst :
    typevar list -> typename list * (typevar, typ) Util.Pmap.pmap

  val apply_type_subst : typ -> (typevar, typ) Util.Pmap.pmap -> typ
end

module type MEMORY = sig
  type memory

  val string_of_memory : memory -> string
  val empty_memory : memory

  type memory_type_ctx

  val empty_memory_type_ctx : memory_type_ctx
  val string_of_memory_type_ctx : memory_type_ctx -> string
  val infer_type_memory : memory -> memory_type_ctx

  module M : Util.Monad.BRANCH
  (* *)

  val generate_memory : memory_type_ctx -> memory M.m
end

module type COMP = sig
  include TYPED
  module Memory : MEMORY

  type opconf = term * Memory.memory

  val get_callback : term -> (name * value * eval_ctx) option
  val get_value : term -> value option
  val is_error : term -> bool
  val get_raise : term -> value option
  val compute_nf : opconf -> opconf option
  val get_typed_term : string -> in_channel -> term * typ * name_ctx

  (* We retrive a module declaration and its signature from the two in_channel taken as input.
     We evaluate the list of computation declarations into a list of value declarations together with the memory
     generated by this evaluation. *)
  val get_typed_val_env :
    in_channel -> in_channel -> val_env * Memory.memory * name_ctx * name_ctx
end

module type WITHNUP = sig
  include COMP

  module Nup :
    Nup.NUP
      with type name = name
       and type value = value
       and type typ = typ
       and module M = Memory.M
end
