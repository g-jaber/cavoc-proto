- [x] Rename bipartite.ml into strategies.ml
  - [x] Incorporate game-indexing in its signature
- [x] Remove the need for Lts.Interactive.INT, by only using Lts.Typing.Game and Lang.Interactive.LANG
- [x] Rework the product LTS by using Lts.Typing.Game
- [ ] Introduce the notion of History-enhancement as a functor from Typing.LTS to Typing.LTS  rather than a module of signature Hislts.HISLTS
- [x] Define a MOVETREE interface
- [x] Implement a functor from MOVETREE to Lang.Interactive.LANG
- [x] Remove the need for CONT_NAMES
- [x] Add a Names submodule to the Moves interface
- [x] Remove the Int submodule of the Strategy.INT_LTS signature
- [x] Design a specific Typing LTS for POGS
- [x] Provide an eval function rather than a compute_nf + abstract_nf in Lang.Interactive.LANG signature
- [x] Rework type_check_abstract_val in nup.ml
    - [x] Take a lnamectx as parameter and check freshness of new names wrt this lnamectx
- [ ] Add a store typing context for moves
- [ ] Define a functor from MOVES to POLMOVES
- [x] Propose a specified signature NAMEDMOVES where move type is defined as name*a_nf
- [x] Add a Namectx signature
- [x] Create a specific signature Lang.Interactive.LANG_WITH_INIT 
- [x] Use Typectx for storectx
- [x] Create a module signature for renamings
- [x] Create a functor from Names and Types to Namectx
- [x] Make the type Namectx abstract in lang/
- [ ] Replace the use of is_cname by a Question/Answer tag on moves
- [x] Write functors for creating callable or non-callable NAMES modules
- [x] Use different NAMES modules for Polymorphic names and for Function names
- [x] Add a functor to aggregate two Typectx
- [x] Implement a function Typectx.add_fresh
- [x] Encapsulate all the use of fresh_name in add_fresh
- [x] Inline a lnamectx parameter in Direct.generate_abstract_val
- [x] Use TYPECTX interface in RefML/type_ctx.ml
- [x] Make namectx abstract in RefML/nup.ml
- [x] Switch to a presentation using De Bruijn indices
- [x] Remove the need of get_transmitted_names
- [x] Remove the need of get_negative_type
- [ ] Remove the need of is_callable
- [x] Transform type_check_abstract_val
- [x] Make interactive_env type abstract
- [x] Cleanup the TYPECTX interface
  - [x] Remove add
  - [x] Remove mem
- [x] Use typed interactive environments
- [x] Keep the Opponent and the Proponent polymorphic names as two distinct namespaces
- [x] Handle reaching a failed program via the EvalMonad
- [x] Manage to print De Bruijn names in move with offset
- [x] Embed a Name module inside Namectx
- [x] Embed a Namectx module inside Moves
- [x] Embed a Namectx module inside IEnv
- [x] Embed a Renaming module inside IEnv
- [x] Embed a Renaming module inside Moves
- [x] Define the weakening over ienv
- [x] Define the tensor of ienv
- [ ] Define an interface for the monoid action for substitution
- [x] Remove concat map in IEnv and introduce copairing
- [x] Switch to a presentation with typed moves
- [x] Implement a notion of Stackctx and of Stackenv for direct.ml
- [x] Pass a namectx argument to abstracting_value to handle correctly the empty ienv
- [ ] Switch from val get_nf_term : term -> normal_form_term to val get_nf_term : opconf -> normal_form_term*store
- [ ] In cps.ml, use named opconf rather than named terms
- [x] Add a function add_fresh on renamings
- [ ] Do not embed Renaming module inside IEnv
- [ ] Simplify AggregateCommon by supposing that the type of name is always an Either
- [ ] opconf should comes with their namectx and storectx typing
- [ ] add a subject_name function 
